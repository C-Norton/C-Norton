Hi, My name is Channing Norton; though you may see older references to me and my work by the name Channing Helmling-Cornell, or variations thereof, as not all services liked how long my old last name was, or the hyphen.

This GitHub serves as my portfolio as a software developer. It was last updated on 2021/22/06

I pride myself on being a technology generalist that can learn how to produce quality of work in a variety of areas quickly, with a solid base of fundamental skills.

This document will outline the projects I have done, the technologies I have worked with, what I'm looking to learn, and what I'm working on right now. Not all of my repositories are public, and not all the code I've produced is mine to share or showcase. Furthermore, smaller projects like one off scripts may not ever get entered into version control, though anything spanning more than a day or two's work for me does end up here now that github finally has private repos for free.

I've broken these technologies up by category. Programming languages at the top, IT platforms and skills at the bottom

## Skill levels

#### Exposed

:large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:

Exposed skills are those that I have toyed with briefly, or worked with tangentally on a project. I would not be confident in immediately producing work relying on those skills, but would have a head start on learning them quickly by virtue of the familiarity gained. This is equivalent of 1 to 5 hours of working with the technology, possibly more for particularly large technologies with lots to learn.

#### Explored

:large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:

Explored skills are skills I've worked with briefly, say as a single use on a project. They aren't skills I'd be comfortable say, putting on a resume, but I've certainly worked with the technology in question in a more than insignificant way, I simply haven't gained a high degree of experience or expertise with the skill in question. I know enough to be dangerous, but not necessarily a ton of nuance. This is equivalent to about 5 to 20 hours of work with the technology in question. I've perhaps started a project in it, but not finished it for one reason or another, or I've completed a project that relies on it, but not TOO heavily. I'm confident in my ability to learn this skill ***far*** faster than learning from nothing, but I also feel I need more time with it to truly understand it.


#### Proficient

:large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond:

Proficient skills are those I've worked with heavily. For most skills, this is at least 20 hours, but larger skills (especially large libraries with lots of classes and large tomes worth of documentation) may require well over 100 hours of work to reach a level of skill that I would consider profiecient. I might not know about every nook and cranny of the technology in question, but I am deeply familiar with the important elements of it, and know where to best find more information. If there's a problem to be solved with this technology, I can get it done, even if it takes a bit of research here and there. I've done at least one project that significantly applys this skill, be it in industry, academia, or personal projects, possibly several.

#### Highly Proficient
:large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond:

Highly proficient skills are those which I have worked in extensively. There is not a single skill that I put this badge on that I have not worked in for at least 200 hours in one form or another. I've worked with this skill in multiple projects, and it is typically going to be a weapon of choice for me for the problems it is good at solving. I know how to use it, I know when to use it, and I know when NOT to use it in favor of the alternatives. I could likely write a rant or three on the flaws present in this technology. I've not used every corner of it extensively, but I know where they all are. If given a problem that this technology can solve, I will know what tools it provides for solving said problem without having to research, but I might need to scan some documentation in order to figure out how to best utilize some of them. The core tools within the technology I've made use of the most I know like the back of my hand. I likely have a version that I'm more familiar with, and my familiarity is suficient that that actualy matters.

#### Mastered 

:large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond:

Mastered skills are those I consider myself truely complete in. There's always more learning to be done, of course, but either the technology in question is small enough that its possible to truly understand every single feature, configuration, and syntax quirk, or, for larger technologies, this usually implies hundreds and hundreds of hours of work in it, at least, to the point where if there's a type of problem the tool can be used for, I've likely used it that way, and misused it in several others. This is likely a go to tool of some kind for me. I usually keep up to date with the updates to the tool to maintain this level of skill, or list a specific version that I am up to date on. ~~I also consider a tool mastered if my wife reports me talking in my sleep about it on more than one occasion.~~


# Higher Level Programming languages

C

:large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond:

C#

:large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond:

C++

:large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:

Java

:large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond:

JavaScript

:large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:

Python

:large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond:

Ruby

:large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:

Rust

:large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:

Scala

:large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:

Smalltalk

:large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:

SQL

:large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond:

VBA

:large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:


# Assembly Languages

MIPS

:large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond:

Arm Cortex M0+

:large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:

PowerPC ISA 1.10

:large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:


# Hardware Description Language

VHDL

:large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:


# Shells, Scripting languages, and automation systems
Bash
Powershell

# Low code / IPAAS / no code platforms
# Frameworks, APIs and Libraries
# Platforms

# Skills I am looking to learn
I may have exposed myself to these skills very, VERY briefly, but not enough to put above. I also may have explored them further since this document was last updated

Erlang
Perl
Prolog
Lisp
Typescript
Haskell

#### Languages
#### Frameworks and Libraries
#### Platforms

