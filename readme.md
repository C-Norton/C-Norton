# Introduction
Hi, My name is Channing Norton; though you may see older references to me and my work by the name Channing Helmling-Cornell, or variations thereof, as not all services liked how long my old last name was, or the hyphen.

This GitHub serves as my portfolio as a software developer and IT professional. This document was last updated on **2023/06/08**

I pride myself on being a technology generalist that can learn how to produce quality work in a variety of areas quickly, with a solid base of fundamental skills.

This document will outline the projects I have done, the technologies I have worked with, what I'm looking to learn, and what I'm working on right now. Not all of my repositories are public, and not all the code I've produced is mine to share or showcase. Furthermore, smaller projects like one off scripts may not ever get entered into version control, though anything spanning more than a day or two's work for me does end up here now that github finally has private repos for free. Final note is, to avoid making academic dishonesty easier, the code for my coursework at RIT or other institutions is ONLY in private repos, if its entered here at all. Throughout much of university I actually used Mercurial rather than Git, purely because, for one person projects, git is a bit overkill.


# NOTE: THIS DOCUMENT IS STILL A WORK IN PROGRESS. WHILE IT IS A LIVING DOCUMNENT, AND WILL NEVER BE "DONE," IT IS VERY MUCH NOT FILLED OUT.

# Key for this Document
<ul>
  
## Table of Contents
  
## Skill Level Criteria
<ul> 
<details><Summary>Expand</summary>

Level<img width=150 /> | Symbol<img width=925 />  | Description and Criteria<img width=650 />
------ | ------- | -------
Exposed | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | Exposed skills are those that I have toyed with briefly, or worked with tangentally on a project. I would not be confident in immediately producing work relying on those skills, but would have a head start on learning them quickly by virtue of the familiarity gained. This is equivalent of 1 to 5 hours of working with the technology, possibly more for particularly large technologies with lots to learn.
Explored | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | Explored skills are skills I've worked with briefly, say as a single use on a project. They aren't skills I'd be comfortable say, putting on a resume, but I've certainly worked with the technology in question in a more than insignificant way, I simply haven't gained a high degree of experience or expertise with the skill in question. I know enough to be dangerous, but not necessarily a ton of nuance. This is equivalent to about 5 to 20 hours of work with the technology in question. I've perhaps started a project in it, but not finished it for one reason or another, or I've completed a project that relies on it, but not TOO heavily. I'm confident in my ability to learn this skill ***far*** faster than learning from nothing, but I also feel I need more time with it to truly understand it.
Proficient | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | Proficient skills are those I've worked with heavily. For most skills, this is at least 20 hours, but larger skills (especially large libraries with lots of classes and large tomes worth of documentation) may require well over 100 hours of work to reach a level of skill that I would consider profiecient. I might not know about every nook and cranny of the technology in question, but I am deeply familiar with the important elements of it, and know where to best find more information. If there's a problem to be solved with this technology, I can get it done, even if it takes a bit of research here and there. I've done at least one project that significantly applys this skill, be it in industry, academia, or personal projects, possibly several.
Highly Proficient | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: | Highly proficient skills are those which I have worked in extensively. There is not a single skill that I put this badge on that I have not worked in for at least 200 hours in one form or another. I've worked with this skill in multiple projects, and it is typically going to be a weapon of choice for me for the problems it is good at solving. I know how to use it, I know when to use it, and I know when NOT to use it in favor of the alternatives. I could likely write a rant or three on the flaws present in this technology. I've not used every corner of it extensively, but I know where they all are. If given a problem that this technology can solve, I will know what tools it provides for solving said problem without having to research, but I might need to scan some documentation in order to figure out how to best utilize some of them. The core tools within the technology I've made use of the most I know like the back of my hand. I likely have a version that I'm more familiar with, and my familiarity is suficient that that actualy matters.
Mastered | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: | Mastered skills are those I consider myself truely complete in. There's always more learning to be done, of course, but either the technology in question is small enough that its possible to truly understand every single feature, configuration, and syntax quirk, or, for larger technologies, this usually implies hundreds and hundreds of hours of work in it, at least, to the point where if there's a type of problem the tool can be used for, I've likely used it that way, and misused it in several others. This is likely a go to tool of some kind for me. I usually keep up to date with the updates to the tool to maintain this level of skill, or list a specific version that I am up to date on. ~~I also consider a tool mastered if my wife reports me talking in my sleep about it on more than one occasion.~~

</details>
</ul>
</ul>

# Skills

<ul>
  
<details><summary>Computer Languages and Shells</summary>
  
##### Note that I've divided languages into categories by their use. You may find languages that are not exclusively or primarily used for the development of desktop applications in other sections below.
<ul>
<details><summary>Higher level programming languages</summary>

  Language<img width=150 /> | Proficiency<img width=290 /> | Notes<img width=650 />
------ | -------------- | ----------------
C | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: | C is my goto language for anything that it makes sense for. Most of my experience is using the GCC compiler configured for C99. I love the speed, power, flexibility and control C offers. I recognize that it certainly falls off in programmer efficiency for large scale applications, so for anything that doesn't need the level of control that's going to be a large codebase, I typically default to C#
C# | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: | C# is a beautiful language. It's everything I love about java, with 90 ish percent of the flaws of java fixed, and some nice, new features. While I may have learned Java first, C# feels like the language it was trying to be. While I have a bit less experience in it, it is my go to tool.
C++ | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | My experience in C++ is limited, and a lot of my knowledge comes from the similarities with C, rather than C++ specifically. I've had a few small dabblings with it, but nothing to write home about.
Java | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: | Of any language, Java is the one I am most experienced in, by far. The only thing that begins to rival it in that respect is C. My familiarity is with Java 8 and before primarily. It's a solid language, but the JRE has... issues, and working in it feels antiquated to me compared to other, newer languages that fill a similar niche. There's just too much redundant code to be written, and I feel like my life is nothing but getters and setters.
JavaScript | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | Not a fan of Javascript. I can hack it, but I avoid it at all costs. Typescript looks like a solution to my hatred of it, but I've not looked into it. I'm looking to expand both my proficiency and tolerance of Javascript with my "Foundry Accessibility Toolkit" project, featured further below on this page.
Python | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I primarily use python for scripting, OS automation, and data processing. As such, while I could pick it up quickly, I'm not super well versed in the object oriented side of the language, as I've not used python for large projects. To me, it is a more flexible wrapper for OS shells that allow me to do logic and data processing far easier than doing it directly in shell.
Prolog | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | Very limited experience in Prolog. Specifically SWI-Prolog. I have a lot to learn from it as a language, and want to get back to it.
PHP | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I picked up PHP as part of my work with the University of Rochester. I was replacing a developer who worked primarily in PHP, we were, at the same time, replacing many of the systems he worked on. As a result, I had to familiarize myself with existing codebases, but the amount of new code I wrote was limited to band-aids and tweaks while we worked to sunset the associated systems. Therefore, I've read quite a bit of PHP, but written only a little.
Ruby | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I've worked with Ruby in particular for development of plugins for ArchivesSpace, a tool based on the Rack web framework. While my total time in Ruby is limited, I've had to dive deep into its internals to diagnose a few highly specific issues related to that project.
Rust | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | Rust looks like a GREAT system implementation language, and generally solid for close to metal programming. All the control of C, all the comfort of a modern language. I want to learn rust on my next project that needs that level of control, I've just not run into a use case for it at this point, as I don't really do that kind of work these days. I would love the opportunity though.
Scala | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | Scala. I like Scala. While I've devoted myself over the next few projects to mastering C#, Scala is 100% my next language of that ilk to learn. Since mid level OO languages are my sweet spot, I anticipate exploring more with it soon.
Smalltalk | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I worked with smalltalk a little bit in university. It taught me a lot about solid OO programming. While its age shows, it's purity appealed to me, and I'd like to work in it more
SQL | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | H2 dialect, but it's SQL, to say its easy to switch between is an understatement.
VBA | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | This goes without saying, but VBA is an abomination. There are, however, some things that probobly should not be done in excel, that if you want to do in a spreadsheet, VBA is your only option. As such, I've worked a little in VBA. 
</details>
  
<details><Summary>Shells, Scripting languages, and OS automation systems</summary>

Technology | Proficiency | Notes
----- | ----- | ------
AutoHotkey | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: |  I love autohotkey as a means of expanding what I can get done on Windows, and addressing some of the shortfalls in customization and functionality of the OS. I haven't gotten too crazy with it, but I have worked with the MS office library for AHK to automate some functions in Outlook, such as the creation of rules.
Bash | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: | If I could have one shell, bash would be it. Most of my bash experience comes from living on Arch linux for several years, and my current position as a software support specialist for software that runs on CentOS 7. While for most automation tasks I'm more likely to open up python for bash, for quick and dirty text manipulation, bash is very usable.
CMD | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: | As a Windows admin first and foremost for larger environments, CMD is my bread and butter. While powershell is nice, for most maintence tasks, CMD is just... easier, with less picky syntax, even if it is living in the past a little bit. Its often also just easier to get a CMD shell in half functioning windows environment, so I don't consider the proficiency a waste.
Powershell | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | Powershell is a skillset that I've picked up bits and pieces of. It's a powerful tool, but there's a LOT there. I've used it primarily for writing scripts to automate active directory bulk operations. I've looked a little bit at Powershell's integration with the .Net ecosystem, and, while it looks very powerful, that's a rabbit hole of learning I have not yet had time to go down. I love working in powershell, I just have a preference for CMD due to years of comfort in it.
WMIC | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:  | I've explored WMIC/WMI briefly as a solution to the specific technical problem of uninstalling certain programs via Connectwise Control's "Backstage" environment, with the goal being to perform these operations without end user interruption when scripting out an install was not possible due to limitations by the installer package. While I know it's primarily used as a Powershell utility, I actually have primarily interacted with WMIC via CMD. I recognize that there's a LOT more the tool can do than forcing program installations, I've just not run into cases where I've needed it.
Zshell | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | I'm capable in zsh, and, if it were sufficiently popular as an embedded alternative to bash, I could see myself loving it more. As is, it's niche, but nice, I guess. I wouldn't say that, beyond the customization and color features that I've explored much of the areas it has a leg up on bash all that much. From what I've seen, it looks nice
</details>
<details><summary>Markup, Notation, and Text Processing Languages</summary>

###### Obviously, with a good portion of these languages/ filetypes, there's not a TON to them. As such, the hourly specifications in the "Skill levels" portion doesn't *really* apply. The proficiency level relates to the amount I've worked with files in the format, and my overall level of comfort with the syntax. There's a lot more to RegEx than YAML, for instance, so more work for RegEx to reach a similar level of comprehension.

Technology | Proficiency | Notes
----- | ----- | ------
CSS | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I've worked a little with CSS. I'm very much a backend guy; my visual design skills are lacking, so I don't have a ton of need for CSS. That being said, I've made a few websites here and there, and have picked up some knowledge in CSS as a result.
HTML5 | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | See the above. Typically, if I'm making a website, its a utilitarian thing, so I can stick with HTML5 as a relatively pure platform, hence my additional experience with it.
JSON | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I've used JSON files as a means of storage and serialization for a number of smaller projects. I'm familiar with the format and writing parsers for it.
Markdown | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: | 
Regular Expressions | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: | While I won't claim to have the entire language of RegEx memorized, I do have the basics sufficient for most searches down without reference, and I can construct an expression to check what I need to quickly. I've used it frequently as a tool for data sanitization and to clean up files full of messy data that I want to process. I'm most familiar with Java's scanner dialect of Regex, followed closely by the Perl implementation.
XML | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | It's XML. It's not fancy. I've written a few parsers here and there, but not used it extensively, But it's also human readable.
YAML | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Everyone's favorite XML/JSON alternative, I've used a LOT of YAML over the years. I've written parsers, configured systems that consisted of hundreds of YAML files for configuration, and generally gotten down and dirty. It ain't a markup language, but it's my favorite markup language. That said, despite my familiarity with it, if I'm doing a new project, I'll do XML or JSON, because that's the direction the industry is going.

</details>

<details><summary>Assembly Languages and ISAs</summary>

Technology | Proficiency | Notes
----- | ----- | ------
MIPS | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: | I've worked as extensively in MIPS as one can bearing in mind that hardware implementations of the ISA are few and far between. I'm not an expert on any particular implementation, but I've written software in it, and tutored in it.
Arm Cortex M0+ | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | My exposure to the Arm Cortex M0+ ISA is limited, but more than nothing. I mostly used it for a course in college to a limited capacity.
PowerPC 1.10 | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | My Power PC knowledge comes from attempted submissions to the Dolphin GameCube Emulator project. As such, my knowledge is limited to early 2000s versions of the ISA, and are VERY limited in use case.
</details>

<details><summary>Hardware Description Languages</summary>
 
###### I originally was exposed to Hardware Description Languages in college. While I picked up VHDL fairly well, I did not pursue things further as computer engineering simply was not my cup of tea. I do not anticipate pursuing VHDL further, though, if I had to work on projects using HDLs to a limited capacity, I would be comfortable. I have neither the experience, nor the skillset to design hardware or FPGAs. I can read and understand the work of others, however.

Technology | Proficiency | Notes
----- | ----- | ------
VHDL | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | VHDL is my greatest enemy, and the main reason I looked to move higher in the abstraction stack than computer engineering. I hear Verilog is better. Personally, I think that assembly is a much better option. Leave the circuits to the electrical engineers.
</details>
</ul>
</details>

<details><summary>Operating Systems and Hypervisors</summary>

###### As a whole, for the desktop, I typically prefer Windows for most purposes, but for software development, I typically prefer Linux OSes for the flexibility of other window managers and customization options. For server uses, I opt for the correct tool for the job. For small and medium businesses, that is usually windows, but for anything performance intensive, or for larger networks, Linux servers are the way to go.
<ul>

<details><summary>Desktop Operating Systems by Vendor and Version</summary>  

Refers to proficiency BOTH with using the OSes personally, and supporting users using the OS in small to medium business settings (defined here as having a fileserver, directory server, cloud or onprem email, DNS and print server may or may not be present, with fairly homogenous enviornments of OSes, save Mac, for which I assume windows servers.)

OS | Proficiency | Notes
------ | ------- | -------
Windows XP | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: | I've supported XP in critical legacy applications, as well as, in my limited pentesting experience, worked to exploit XP a few times. It's not my favorite windows OS, but I still miss elements of it to this day. 
Windows Vista | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: | Okay, but does this actually MATTER to anyone. Vista is where I really started digging in depth into Windows. It has a special place in my heart, even if it's not popular.
Windows 7 | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: | 7 remains my favorite OS for management and general day to day use. I don't use it or deploy it anymore, of course, but I do wish there was a 7ish skin of windows 10 that brought back some options that got removed, some registry settings that got changed, and killed off windows 10 settings in favor of control panel. It has its quirks, and I know as many of them as one perosn reasonably can.
Windows 8 | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | See notes for vista. Does anyone care about 8? It has no special place for me, other than perhaps the trash can. I know how to work with it, though. A lot of my proficiency comes from server 2012 crossover. 
Windows 10 | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: | It's 10. Everyone's on it, and has been for years. I've supported it for years. I still don't like certain aspects, but I know how to live with it. Overall, 10 is the most stable windows yet, which is a very good thing, even if it does take a lot of control away from admins. 
Windows 11 | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I've not gotten the chance to work with 11, beyond passingly, quite yet. I'm not exactly happy with some of the UI decisions, but some of the changes to the admin side of things look very promising.
Linux (Arch) | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: | I fulltimed arch for several years, which was a learning process, to say the least. I'd never run Arch as anything but a hobby; that said, it makes the control freak in me _very_ happy
Linux (Debian) | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I've worked with Debian, mostly on the desktop. While I like the package management system more than the Redhat side of the house, overall, it's far from my favorite distro. It's rock solid, though, so I don't mind using it too much.
Linux (Fedora) | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | Fedora (or OpenSuse) is likely to become my goto desktop linux distribution over the next few years. I may not be the biggest fan of Gnome, but I dislike it less than the other desktop environments that come by default on the major distros. RPM isn't my favorite package system, but that's largely unimportant at this point, and I'm very familiar with Yum. Fedora just... works in a way that most other distros don't.
Linux (Mint) | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I've used Mint to teach people needing to know Linux basics to serve as a transition into Linux for Windows users. It is effective in that role, but I feel that it handicaps most of the good of Linux in terms of customizability for ease of use. I wouldn't run it long term for anything, as I'd either put a more flexible distro in place, or use windows, depending on use case.
Linux (OpenSuse) | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I like OpenSuse a _LOT_. Having a central "Control Panel" for system configuration addresses one of the most important usability pitfalls of Linux, in my opinion. Package management is a bigger pain on OpenSuse, due to the incompatible RPM format, and Suse being a smaller distro. If it were more compatible with either of the two major families, I'd like it even more. I've also run into serious performance concerns on some hardware that I haven't for other distros, but that was also running the Tumbleweed variant, so I don't fault OpenSuse for it. If I could pick one distribution for further development and deployment by the Linux community, it would be OpenSuse. I fulltimed Tumbleweed on the desktop for about 2 months.
Linux (Ubuntu) | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | Ubuntu is... Ubuntu. It's stuck between being a serious, powerful distro, and being a transitional, beginner distro. It serves the role of "Powerful, but with setbelts" quite well. I full timed it for about 6 months, before switching to OpenSuse after trying to entirely replace both Xorg and the Desktop Environment with Wayland and i3 broke a lot of Ubuntu's internals. The Deb package system is easily the best within the Linux ecosystem, however, and I feel that Ubuntu's implementation is fantastic. Ubuntu is a VERY solid tool for the right uses.
MacOS (Versions < 10.7) | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | Prior to OSX Lion, I was using OSX as a user to a relatively high degreee, and did some basic administration work as well. I am extremely rusty, but the underlying knowledge and principles are still there.
MacOS (Versions 10.7 - 10.13) | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | During the Lion to High Sierra era, I was doing more in depth administration work on Macs, but using them far less as a user. Most Macs I supported were in Microsoft dominated environments, with onprem active directory, and no Mac device management software like JAMF. As such, I am well enough versed in the idiosyncrasies of such environments. 
MacOS (Versions > 10.13) | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | After High Sierra, I know that Macs fundamentally changed, and the number I had to support, and therefore my frequency of interaction declined dramatically. As such, I am not especially confident in being able to support the modern Mac ecosystem in large numbers. My proficiency is such that supporting individual Macs is well within my abilities, but supporting a primarily Apple Centric fleet would require more experience on my part before being comfortable.
</details>
  

<details><summary>Server Operating Systems by Vendor and Version</summary>  

OS | Proficiency | Notes
------ | ------- | -------
Windows Server 2008 and before | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | Server 2008 was my introduction to Windows Server. While I've worked on earlier, the latest and greatest when I started was 2008. There's really not much to say here. It's Windows Server, It's Vista based. I love Vista, but 2012/7 came out right after I started working on servers, and I didn't have a position with legacy deployments at that point, so as soon as I cut my teeth, I stopped really seeing it.
Windows Server 2012 | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I love Windows 7. I therefore loved Server 2012. I haven't seen it in prod in a long time. The industry kinda got stuck between the servers still running 2003, and the servers that could be reliably updated that moved to 2016 and 2019. When I see it, I don't think of it as any different than the other modern Windows Servers, other than the tweaks to AD since then, like the AD trash can. So far, this approach has not failed  me.
Windows Server 2016 | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: | When I went from working with servers occasionally to working extensively, Server 2016 was the latest Windows Server. At the time, I was in school, and worked extensively with server 2016 VMs, understanding the underpinnings of modern IT, and Cybersecurity. From there, I moved to the managed services space, which had me supporting hundreds of Server 2016 deployments with a variety of configs, workflows, hardware, needs, and so much more. I have an intimate understanding of Server 2016 that can only come from installing it hundreds of times, and troubleshooting issues with deployments I was not familiar with for years.
Windows Server 2019 | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: | When 2019 began to replace server 2016, I was still in managed services. At this point, IT was my vocation, so, similar to the Windows 7 and 8 replacement by Windows 10, the knowledge transfer occurred through active use. I love 2019 far more than 2016 for its sensible UI and improvements to tools like Powershell and Task manager. While a part of me still longs for 7 on the desktop, there is no such misgivings for Windows Server.
Windows Server 2022 | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: | I've got limited experience with 2022. From what I've seen, it's more of the same for Windows server. That said, my experience is limited. I am not intimately familiar with the new changes. It's also been out less than 7 months at time of writing, so.....
Linux (RHEL/CentOS/Rocky) | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: | My position, at time of writing, has me as part of a team supporting software that runs on RHEL and CentOS 7, across hundreds of deployments, both in public clouds, and on hypervisors running on local hardware (Note: My company does not manage any of the hardware, and my department does not manage the public cloud side of things. We get an IP address for a deployment, and that's as far down as we go). I am therefore very familiar with these OSes, especially CentOS. I use Rocky in my personal work when I need a RHEL based OS at this point. 
Linux (Ubuntu) | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | Prior to my current position, Ubuntu was my goto Linux server of choice, that said, I used Linux far less than I do today. I primarily built Ubuntu images from the minimal network installer, and refrained from using a GUI unless needed by the usecase.
Linux (Debian) | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I've used Debian sparingly as a Server OS. That said, I've worked with its package management a little bit. The foundation is there for quick learning. 
Linux (OpenSuse) | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | I want to like SuSE on server. I love it on the desktop, in theory. Software support is a pain, but it is VERY nice. I wish I had more experience here.

</details>



<details><summary>Hypervisors</summary>

Hypervisor | Proficiency | Notes
------ | ----- | ------
Hyper-V | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: | I've run several small deployments on Hyper-V, and supported quite a few others. I fundamentally find it to be good at what it does; a great, packaged answer for minor virtualization needs in windows environments, that lacks the features of the larger hypervisors, but is not in a market position to need them either, as it's not TRYING to be the engine behind an entire datacenter.
VirtualBox | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: | Virtualbox is a good piece of software for what it does. Like hyper-V, it's limited, but strong in its limitations. For lab work as opposed to full deployments, it's fantastic. I wouldn't use it for anything else, though, even with a firm understanding of basically all its features.
VMWare VSphere/ESXI | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I've not created new deployments with VMWare, but I have maintained smaller deployments (~20 VMs or fewer). Fundamentally, the licensing cost of VMWare is hard to justify vs the Xen ecosystem, as there is feature parity, though the ease of finding talent familiar is a factor.
VMWare Workstation | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I've used VMWare workstation as a lab hypervisor pretty extensively. I like it quite a bit more than Virtualbox, but also find it hard to justify the cost vs free software, seeing as it is for a lab environment, unless, of course, one's prod is VMware as well.
XCP-ng / Xen | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | I run a production environment of 35 VMs, archiected and deployed from scratch on XCP-ng. I am the only engineer involved in this project, which is used to power my small business, run on a dell poweredge r720. As such, XCP-ng is my hypervisor of choice, as I am most familiar with it in production environments 

</details>



<details><Summary>Niche/Other</summary>

OS | Proficiency | Notes
------ | ----- | ------
ChromeOS | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I have managed a deployment of a few dozen Chromebooks given to students and teachers. Overall, I like the OS. What it lacks in remote management tools is made up for by the lack of a need for remote management. It's very easy to train people on, and very hard to screw up by the end user. I would absolutely consider using it again, especially in educational settings, or other places where workloads could be done entirely in SaaS applications.
FreeBSD | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I spent several weeks, years ago, trying to set up FreeBSD as a firewall and gateway for my home network. In the end, my frustration with FreeBSD resulted in my switching to PFSense for this purpose. That said, I learned quite a bit in my attempt about a variety of subjects. 
OpenBSD | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | OpenBSD was my first foray into the the BSD ecosystem, learning from a book of exercises in OpenBSD. With my additional experience in Linux that I have gained over the years, I recently returned to OpenBSD to learn more about the platform, as it seems to have some good, niche uses. I appreciate the depth of its documentation.
PFSense | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | PFSense is a quality operating system for network devices. Between my own personal explorations with it, my work within networking classes that relied on it, as well as my implementation of it in my home lab, I can certainly get things done in PFSense. That said, I recognize that it is a platform with substantial depth that feels impossible to master without exposure in larger scale environments with more complicated security and network segmentation needs.
QubesOS | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | QubesOS is... interesting. I've worked with it a little, and it's piqued my curiousity. Using it invokes the kind of security-paranoia that I would love to have time and mental bandwidth for, while not serving much purpose outside of VERY niche usecases.


</details>
  </ul>
 
</details>
</details>
  
<details><summary>Low code / IPAAS / no code platforms</summary>

Platform | Proficiency | Notes
------ | ----- | ------
Microsoft Power Apps | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I have some exposure to PowerApps as a means of bringing data into Power Automate. Beyond that, my experience is fleeting.
Microsoft Power Automate | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I've worked with power automate slightly, in attempting to pull data from Dynamics CRM and process it. I like it quite a bit, and, as I'm already a heavy m365 user, I will likely continue to integrate it where I would otherwise use Zapier.
Zapier | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | of all the IPAAS platforms, I am personally most experienced with Zapier due to its depth of integrations with the tools and platfors I've needed to work with. Overall, I do prefer Power Automate to Zapier in terms of features and ease of use.
</Details>
<details><summary>Frameworks, APIs and Libraries</summary>

Platform | Proficiency | Notes
------ | ----- | ------
CImg | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I worked briefly on CImg with a student I was tutoring. I learned the basics of the library to assist him with some homework. Overall, my time with it was fleeting, but I'd certainly be willing to come back to it, it was a fairly intuitive library.
CUnit | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | My CUnit familiarity comes from its overlap with JUnit. I've looked to integrate it into some of my own projects as well, but I tend to flit from project to project, and haven't had anything stick yet.
.Net Core | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | If I were building a desktop application in the modern era, I would be building it in C# using .Net core. In fact, one of the projects I started and abandoned, as it was FAR more than I could chew (I knew it at the time, but blazed on anyways), YANTA, is just that.
.Net Framework | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | Through my experience in Unity, as well as working with YANTA, I've worked in the .Net framework quite a bit. As far as massive utility libraries go, I like it better than Java's assortment of libraries.
Glade | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | Glade was the pagebuilder I intended to use for YANTA, as I wanted GTK to be my UI Toolkit. I got it working, then abandoned the project shortly after.
GTK | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | See abovoe. Most of my interaction was with glade iteslf, rather than GTK properly. Overall, YANTA was shaping up to be overengineered for the scope of the project.
H2 | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: | H2 was the database drive foisted upon me for a major group project in College. As a result of an absentee group member, I performed most of the work to get said project working, and became intimately familiar with H2 in the process. At time of writing, I am preparing _SOME_ of this code for release, as I want to ensure I do not make academic dishonesty easier for students that come after.
JUnit | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | RIT's coursework is, for most classes, in java. JUnit is taught as part of the standard curriculum, and its use in all projects of any scale after that point is expected. I usually was not the one on teams who was writing tests, but I still wrote my fair share, and debugged plenty.
Lanterna | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | For the same project that led to my familiarity with H2, I chose Lanterna as our frontend, as it didn't have to be pretty, it just had to work, and be easy. I appreciated its similarity in structure to JavaFX. I would certainly use lanterna again if I needed to create a UI for something in a CLI environment. If I were creating something without the CLI constraints, though, I'd likely use something else. Its almost as much work as a true native GUI, and doesn't exactly look nice. 
Matplotlib | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I've used Matplotlib sparingly in undergrad, as well as with a few tutoring students. It's not that it's bad, just that data visualization is far from a focus of mine. For most purposes, I'd prefer excel.
Mono | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | While exploring candidates for Yanta, I looked at developing on mono, and dismissed it in favor of DotNetCore. I am also exposed to it when building cross platform projects for Unity.
NumPy | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I've used NumPy quite a bit when tutoring students in introductory python courses. If I had to handle and process more data than Excel can really be useful for, it would undobtedly be my first choice. While I've not used the deeper features of it at all, using it to handle basic analysis is well within my grasp. Most recently, I used NumPy and Pandas to process data for a personal project correlating US income by zip code with a number of metrics attempting to define happieness.
Pandas | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | My experience with Pandas is near identical to that of NumPy. Typically, I've used the two in conjunction. Primarily, I use Pandas primarily to parse data, and process it in Numpy. 
SciPy | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I've interacted a little bit with the SciPy section of the Numpy ecosystem. Not very much though. What classes I have worked with have been used primarily for utility functions.
Swing | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: | As part of my work at RIT, I worked with Swing on a variety of projects. I've also tutored students in Swing and built small UI elements in it. Overall, while I don't particularly _LIKE_ working in it, I do know it well, and can get stuff done in it.
TinyDB | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | My abandoned (hopefully soon to be resurrected) mediaDB project was built on TinyDB. For small, disposable projects, I like it far more than trying to set up SQLite or another lightweight database.
Unity | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | I have a particular interest in games programming. My tool of choice has been Unity. In the 2021 GMTK game jam, a game for whom I was the sole programmer was entered. The code for this incomplete game will be added to this github eventually.
</details>
<details><summary>Development Tools, Build Systems, and Version Control</summary>

Platform | Proficiency | Notes
------ | ----- | ------
Git | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: | I feel I know just about all there is to know about Git. I've been using it for nearly a decade now.
Mercurial | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I expirimented with Mercurial in college, to see if there were any major benefits in terms of ease of source management vs git for small, 1-5 person projects. There were not. At this point, I'd use git for one man projects over Mercurial. In situations where Git is unsuitable, mercurial COULD be a good tool for a small team, but I'd really question if there is such a situation where source control is needed, git is unsuitable, and Mercurial is. 
Visual Studio | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I have some exposure to the Visual Studio ecosystem by virtue of being a programmer in the modern era. That said, while I've expirmented with VSCode as an alternative to other tools for a bit here and there, I will still make a JetBrains tool work if at all possible.
Trello | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: | Trello is one of my core organizational tools. I use it constantly, and would not survive without it or a similar tool. As such, I'm intimately familiar. Of course, there's also not a lot to Trello...
Jira | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: | I've used numerous ticketing systems over the years. OF these, Jira is the most popular as it is the only one not specific to the managed services industry. I've been in roles both managing Jira instances and using it as a technician/ developer to track work.
JetBrains IDEs | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Since 2015 my goto toolkit for any programming project I can use them for has been Jetbrains' suite of IDEs; I know how to use just about all of their options to greatest effect in the languages I am familiar with, and have even expirimented briefly with plugin development. I love them, and will likely continue using them until the end of time. I've worked with these tools in Visual Studio centric environments, and am very familiar with converting project configurations between the two ecosystems.
</details>

<details><summary>Development techniques and methodologies</summary>
  
Methodology | Proficiency | Notes
------ | ----- | ------
Test Driven Development |  | 
Agile |  | 
Scrum |  | 
Waterfall |  | 
</details>

<details><summary>Development "Soft Skills"</summary>
  
Platform | Proficiency | Notes
------ | ----- | ------
</details>
<details><summary>Service Delivery Software</summary>
 
Platform | Proficiency | Notes
------ | ----- | ------

</details>
<details><summary>IT Platforms</summary>

Platform | Proficiency | Notes
------ | ----- | ------

</details>

<details><summary>Important Unix Administration Utilities and Windows Server Modules</summary>
  
Platform | Proficiency | Notes
------ | ----- | ------
</details>

<details><summary>Enterprise Networking Ecosystems</summary>
  
Platform | Proficiency | Notes
------ | ----- | ------
</details>

<details><summary>Business Software</summary>
  
Platform | Proficiency | Notes
------ | ----- | ------
</details>

<details><summary>Other Software</summary>
  
Platform | Proficiency | Notes
------ | ----- | ------
ArchivesSpace | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | 
Omeka Classic | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | 
Omeka S | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: | 
WebCRD | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | WebCRD is a platform for Web2Print implementation and commercial printshop management. A prior position of mine was to serve as vendor support for WebCRD. As such, I am proficient in it to the greatest degree that would ever be necessary for other roles. I served as a line of communication between development and our customers in identifying, diagnosing, and resolving issues of all sizes and natures.
</details>
</ul>
  
# Skills I am looking to learn
<ul>
I may have exposed myself to these skills very, VERY briefly, but not enough to put above. I also may have explored them further since this document was last updated

#### Languages

[ ] Erlang

[ ] Haskell

[ ] Lisp

[ ] Perl

[ ] Typescript


#### Frameworks and Libraries
#### Platforms
</ul>

# Projects Completed

<ul>
</ul>

# Projects in progress

<ul>
<li>**Foundry Accessibility Tooklit** - Foundry accessibility toolkit is a project of mine to take Foundry Virtual Tabletop, which I use in my hobby as a roleplayer, and adapt it for better use by low vision users, as I noticed such options were extremely lacking, and one of my players is herself sight impaired.</li>
<li>**GMTK Gamejam 2021** - In 2021, I was the sole programmer for a game. While it was initially planned that 2 other programmers would join our group of 5, both dropped out of the jam midway through due to personal reasons, without code contributions. As such, while we were unable to submit, due to a number of bugs, I still learned a lot about Unity by attempting.</li>
</ul>

# Projects on hold

<ul></ul>

# Open Source

<ul></ul>

# Soft Skills

<ul></ul>

# Work Experience

<ul></ul>
