# Introduction
Hi, My name is Channing Norton; though you may see older references to me and my work by the name Channing Helmling-Cornell, or variations thereof, as not all services liked how long my old last name was, or the hyphen.

This GitHub serves as my portfolio as a software developer. This document was last updated on 2021/22/06

I pride myself on being a technology generalist that can learn how to produce quality of work in a variety of areas quickly, with a solid base of fundamental skills.

This document will outline the projects I have done, the technologies I have worked with, what I'm looking to learn, and what I'm working on right now. Not all of my repositories are public, and not all the code I've produced is mine to share or showcase. Furthermore, smaller projects like one off scripts may not ever get entered into version control, though anything spanning more than a day or two's work for me does end up here now that github finally has private repos for free. Final note is, to avoid making academic dishonesty easier, any work for my coursework at RIT or other institutions is ONLY in private repos, if its entered here at all. Throughout much of university I actually used Mercurial rather than Git, purely because, for one person projects, git is a bit overkill.

I've broken these technologies up by category. Programming languages at the top, IT platforms and skills at the bottom
## Skill levels
<details><Summary>Rating criteria</summary>

#### Exposed

:large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:

Exposed skills are those that I have toyed with briefly, or worked with tangentally on a project. I would not be confident in immediately producing work relying on those skills, but would have a head start on learning them quickly by virtue of the familiarity gained. This is equivalent of 1 to 5 hours of working with the technology, possibly more for particularly large technologies with lots to learn.

#### Explored

:large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:

Explored skills are skills I've worked with briefly, say as a single use on a project. They aren't skills I'd be comfortable say, putting on a resume, but I've certainly worked with the technology in question in a more than insignificant way, I simply haven't gained a high degree of experience or expertise with the skill in question. I know enough to be dangerous, but not necessarily a ton of nuance. This is equivalent to about 5 to 20 hours of work with the technology in question. I've perhaps started a project in it, but not finished it for one reason or another, or I've completed a project that relies on it, but not TOO heavily. I'm confident in my ability to learn this skill ***far*** faster than learning from nothing, but I also feel I need more time with it to truly understand it.


#### Proficient

:large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond:

Proficient skills are those I've worked with heavily. For most skills, this is at least 20 hours, but larger skills (especially large libraries with lots of classes and large tomes worth of documentation) may require well over 100 hours of work to reach a level of skill that I would consider profiecient. I might not know about every nook and cranny of the technology in question, but I am deeply familiar with the important elements of it, and know where to best find more information. If there's a problem to be solved with this technology, I can get it done, even if it takes a bit of research here and there. I've done at least one project that significantly applys this skill, be it in industry, academia, or personal projects, possibly several.

#### Highly Proficient
:large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond:

Highly proficient skills are those which I have worked in extensively. There is not a single skill that I put this badge on that I have not worked in for at least 200 hours in one form or another. I've worked with this skill in multiple projects, and it is typically going to be a weapon of choice for me for the problems it is good at solving. I know how to use it, I know when to use it, and I know when NOT to use it in favor of the alternatives. I could likely write a rant or three on the flaws present in this technology. I've not used every corner of it extensively, but I know where they all are. If given a problem that this technology can solve, I will know what tools it provides for solving said problem without having to research, but I might need to scan some documentation in order to figure out how to best utilize some of them. The core tools within the technology I've made use of the most I know like the back of my hand. I likely have a version that I'm more familiar with, and my familiarity is suficient that that actualy matters.

#### Mastered 

:large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond:

Mastered skills are those I consider myself truely complete in. There's always more learning to be done, of course, but either the technology in question is small enough that its possible to truly understand every single feature, configuration, and syntax quirk, or, for larger technologies, this usually implies hundreds and hundreds of hours of work in it, at least, to the point where if there's a type of problem the tool can be used for, I've likely used it that way, and misused it in several others. This is likely a go to tool of some kind for me. I usually keep up to date with the updates to the tool to maintain this level of skill, or list a specific version that I am up to date on. ~~I also consider a tool mastered if my wife reports me talking in my sleep about it on more than one occasion.~~

</details>
  
# Higher Level Languages
<details><summary>Most proficient in C, C#, and Java. While I'm more experienced and knowledgeable as a Java developer, I prefer C#.</summary>
  
###### Note that I've divided languages into categories by their use. You may find languages that are not exclusively or primarily used for the development of desktop applications in other sections below.
  
Language | Proficiency | Notes &nbsp;
------ | -------------- | ----------------
C | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: | C is my goto language for anything that it makes sense for. Most of my experience is using the GCC compiler configured for C99. I love the speed, power, flexibility and control C offers. I recognize that it certainly falls off in programmer efficiency for large scale applications, so for anything that doesn't need the level of control that's going to be a large codebase, I typically default to C#
C# | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: | 
C++ | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: |
Java | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: |
JavaScript | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: |
Python | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | I primarily use python for scripting, OS automation, and data processing. As such, while I could pick it up quickly, I'm not super well versed in the object oriented side of the language, as I've not used python for large projects. To me, it is a more flexible wrapper for OS shells that allow me to do logic and data processing far easier than doing it directly in shell.
Prolog | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:
Ruby | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:
Rust | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:
Scala | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:
Smalltalk | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:
SQL | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: | H2 dialect, but it's SQL, to say its easy to switch between is an understatement.
VBA | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
</details>
  
# Operating Systems

# Shells, Scripting languages, and OS automation systems
<details><Summary>While I don't have shell documentation memorized, and usually need documentation to hand for the core busybox applications and their equivalents in other OSes, I am generally very comfortable in any kind of shell, and can happily script tasks in them. Shells for networking hardware operating systems covered elsewhere in this document</summary>

Technology | Proficiency | Notes
----- | ----- | ------
AutoHotkey | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: |  
Bash | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: | If I could have one shell, bash would be it. Most of my bash experience comes from living on Arch linux for several years, and to a lesser extent Ubuntu. While for most automation tasks I'm more likely to open up python for bash, for quick and dirty text manipulation, bash is very usable.
CMD | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: | As a Windows admin first and foremost for larger environments, CMD is my bread and butter. While powershell is nice, for most maintence tasks, CMD is just... easier, with less picky syntax, even if it is living in the past a little bit. Its often also just easier to get a CMD shell in half functioning windows environment, so I don't consider the proficiency a waste
Powershell | :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: | Powershell is a skillset that I've picked up bits and pieces of. It's a powerful tool, but there's a LOT there. I've used it primarily for writing scripts to automate active directory bulk operations. I've looked a little bit at Powershell's integration with the .Net ecosystem, and, while it looks very powerful, that's a rabbit hole of learning I have not yet had time to go down. I love working in powershell, I just have a preference for CMD due to years of comfort in it.
WMIC | :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:  | I've explored WMIC/WMI briefly as a solution to the specific technical problem of uninstalling certain programs via Connectwise Control's "Backstage" environment to perform these operations without end user interruption when scripting out an install was not possible due to limitations by the installer package. While I know it's primarily used as a Powershell utility, I actually have primarily interacted with WMIC via CMD. I recognize that there's a LOT more the tool can do than forcing program installations, I've just not run into cases where I've needed it.
Zshell | :large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | I'm capable in zsh, and, if it were sufficiently popular as an embedded alternative to bash, I could see myself loving it more. As is, it's niche, but nice, I guess. I wouldn't say that, beyond the customization and color features that I've explored much of the areas it has a leg up on bash all that much. From what I've seen, it looks nice





# Markup Languages

# Assembly Languages

MIPS

:large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :large_blue_diamond: :small_blue_diamond:

Arm Cortex M0+

:large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:

PowerPC ISA 1.10

:large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:


# Hardware Description Languages

VHDL

:large_blue_diamond: :large_blue_diamond: :small_blue_diamond: :small_blue_diamond: :small_blue_diamond:



# Low code / IPAAS / no code platforms
# Frameworks, APIs and Libraries
# Version Control
# Service Delivery Software
# IT Platforms
# Skills I am looking to learn
I may have exposed myself to these skills very, VERY briefly, but not enough to put above. I also may have explored them further since this document was last updated

Erlang
Perl
Lisp
Typescript
Haskell

#### Languages
#### Frameworks and Libraries
#### Platforms

